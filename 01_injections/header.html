<!-- Utilities for Will-Myers.com Plugins -->
<script src="https://cdn.jsdelivr.net/gh/willmyerscode/toolkit@1/index.min.js"></script>
<!-- Tabs Code CSS From Will-Myers.com -->
<link href="https://cdn.jsdelivr.net/gh/willmyerscode/tabs@5/tabs.min.css" rel="stylesheet">
<script>document.documentElement.classList.add('apreps');</script>

<!-- Dot Cursor by digitalmoves.com.au -->
<script>
document.addEventListener("DOMContentLoaded", () => { // once the page is ready
    // add the element to the body
    const cursor = document.createElement("span")
    cursor.classList.add("dot-cursor")
    cursor.innerHTML = "<span />" // add inner element
    cursor.style.opacity = 0 // hide until mouse move
    document.body.appendChild(cursor)

    // update the dot position on mouse move
    document.addEventListener("mousemove", (e) => {
        if(e.clientX < 3 || e.clientY < 3){
            // hide on edges of screen
            cursor.style.opacity = 0
        } else {
            cursor.style.opacity = 1;
            cursor.style.transform = `translate(${e.clientX}px, ${e.clientY}px)`;
        }
    })

    // add hover effect when over links and buttons
    const targets = document.querySelectorAll("a, button") // CSS selectors for which elements have the hover effect
    targets.forEach((target) => {
        target.addEventListener("mouseenter", () => cursor.classList.add("active"))
        target.addEventListener("mouseleave", () => cursor.classList.remove("active"))
    })
})
</script>
<!-- Dot Cursor by digitalmoves.com.au -->

<script>
document.addEventListener('DOMContentLoaded', () => {
  const html = document.documentElement;
  if (!html.classList.contains('apreps')) return;

  const applyFluidEngineFixes = (root = document) => {
    root.querySelectorAll('[data-fluid-engine="true"].fluid-engine').forEach(element => {
      element.style.setProperty('grid-template-rows', 'none', 'important');
      element.style.setProperty('grid-auto-rows', 'minmax(8px,auto)', 'important');
      element.style.setProperty('height', 'auto', 'important');
      element.style.setProperty('min-height', '0', 'important');
      element.style.setProperty('max-height', 'none', 'important');
    });

    root.querySelectorAll('.page-section, .content-wrapper').forEach(element => {
      element.style.setProperty('padding-top', '0', 'important');
      element.style.setProperty('padding-bottom', '0', 'important');
    });
  };

  /**
   * Per-slide gallery aspect ratios
   *
   * Goal: inside .apreps, let portrait images stay vertical and
   * landscape images read as landscape, even when the Squarespace
   * gallery is configured with a single "aspect ratio" setting.
   *
   * Approach: use each thumb's data-image-dimensions to set a
   * per-slide --ap-aspect variable, which the CSS already uses
   * for aspect-ratio: var(--ap-aspect, 4 / 3).
   */
  const applyGalleryAspectRatios = (root = document) => {
    root
      .querySelectorAll('.apreps .sqs-gallery.sqs-gallery-design-grid .sqs-gallery-design-grid-slide')
      .forEach(slide => {
        const image = slide.querySelector('img.thumb-image[data-image-dimensions]');
        if (!image) return;

        const dimensions = image.getAttribute('data-image-dimensions');
        const match = dimensions && dimensions.match(/^(\d+)x(\d+)$/);
        if (!match) return;

        const width = parseInt(match[1], 10);
        const height = parseInt(match[2], 10);
        if (!width || !height) return;

        const ratio = width / height;
        const isLandscape = ratio >= 1.1; // treat near-square as portrait

        const aspectValue = isLandscape ? '4 / 3' : '3 / 4';
        slide.style.setProperty('--ap-aspect', aspectValue);

        slide.classList.toggle('ap-aspect-landscape', isLandscape);
        slide.classList.toggle('ap-aspect-portrait', !isLandscape);
      });
  };

  const patch = (root = document) => {
    applyFluidEngineFixes(root);
    applyGalleryAspectRatios(root);
  };

  patch();

  new MutationObserver(mutations => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === 1) {
          patch(node);
        }
      }
    }
  }).observe(document.body, { subtree: true, childList: true });
});
</script>
