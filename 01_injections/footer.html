<!-- Image hover list by digitalmoves.com.au -->
<script src="//unpkg.com/@digitalmoves/image-hover-list"></script>
<link href="//unpkg.com/@digitalmoves/image-hover-list/dist/main.css" rel="stylesheet" />
<!-- Image hover list by digitalmoves.com.au -->

<!-- Copy to Clipboard Code Snippet by digitalmoves.com.au -->
<script src="//unpkg.com/@digitalmoves/code-tools"></script>
<script>
  CodeTools.init({ theme: "monokai-sublime" });
</script>

<!-- AP — Artist name overlay (difference) -->
<script>
(function(){
  const LABEL_SEL = '.sqs-html-content h3, .image-slide-title';
  const SLIDE_MATCH = '.sqs-gallery.sqs-gallery-design-grid .slide, .sqs-gallery-design-grid-slide';
  const HOST_MATCH = '.margin-wrapper, .image-wrapper, .thumb-image-wrapper';

  function copyType(from, to){
    const cs = getComputedStyle(from);
    [
      'fontFamily','fontSize','fontWeight','fontStyle','letterSpacing',
      'textTransform','textDecoration','fontStretch','lineHeight'
    ].forEach(p => { try { to.style[p] = cs[p]; } catch(_){} });
  }

  function slideUnderLabel(label){
    const r = label.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;
    let el = document.elementFromPoint(cx, cy);
    while (el && !(el.matches && el.matches(SLIDE_MATCH))) el = el.parentElement;
    return el || label.closest(SLIDE_MATCH) || label.parentElement;
  }

  function hostForOverlay(slide){
    if (!slide) return null;
    // Prefer the wrapper that directly contains the image so we share its stacking context
    const img = slide.querySelector('img.thumb-image');
    if (img) {
      const host = img.closest(HOST_MATCH);
      if (host) return host;
    }
    return slide.querySelector(HOST_MATCH) || slide;
  }

  function ensureOverlay(label){
    const slide = slideUnderLabel(label);
    if(!slide) return;
    const host = hostForOverlay(slide);
    if(!host) return;

    const block = label.closest('.sqs-block') || label.parentElement;
    if (block) block.classList.add('ap-hide-original-label');

    let overlay = host.querySelector(':scope > .ap-name-overlay');
    if(!overlay){
      overlay = document.createElement('div');
      overlay.className = 'ap-name-overlay';
      host.appendChild(overlay);
    }

    const text = (label.innerText || label.textContent || '').trim();
    overlay.textContent = text;
    copyType(label, overlay);

    const rS = host.getBoundingClientRect();
    const rL = label.getBoundingClientRect();
    overlay.style.top  = Math.round(rL.top  - rS.top)  + 'px';
    overlay.style.left = Math.round(rL.left - rS.left) + 'px';
    overlay.style.height = rL.height + 'px';
    overlay.style.lineHeight = getComputedStyle(label).lineHeight;
  }

  function scan(){ document.querySelectorAll(LABEL_SEL).forEach(ensureOverlay); }

  const tick = () => requestAnimationFrame(scan);
  if(document.readyState !== 'loading') tick();
  else document.addEventListener('DOMContentLoaded', tick);
  window.addEventListener('load', tick);
  window.addEventListener('resize', tick);
  window.addEventListener('scroll', tick, {passive:true});
  document.addEventListener('sqs-content-loaded', tick);
  document.addEventListener('wmTabs:afterInit', tick);
  document.addEventListener('wmTabs:afterOpenTab', () => setTimeout(tick, 100));
})();
</script>
<!-- Copy to Clipboard Code Snippet by digitalmoves.com.au -->

<!-- Infinite auto scroll by digitalmoves.com.au/plugins -->
<script src="https://unpkg.com/embla-carousel/embla-carousel.umd.js"></script>
<script src="https://unpkg.com/embla-carousel-auto-scroll/embla-carousel-auto-scroll.umd.js"></script>
<script src="//unpkg.com/@digitalmoves/infinite-auto-scroll"></script>
<!-- Infinite auto scroll by digitalmoves.com.au/plugins -->

<!-- Tabs Code Javascript From Will-Myers.com -->
<script src="https://cdn.jsdelivr.net/gh/willmyerscode/tabs@5/tabs.min.js"></script>

<!-- AP—REPS v0.95 — per-slide aspect via CSS variable + enforce grid gaps after lazyload + wmTabs bridges + idempotent init -->
<script>
(function () {
  if (window.__apAspectInitDone) return;
  window.__apAspectInitDone = true;

  var GAP_PX = 0; // vertical row gap in pixels (handled in CSS)

  function classify(img) {
    if (!img) return;
    const slide = img.closest('.slide');
    if (!slide || !slide.closest('.sqs-gallery.sqs-gallery-design-grid')) return;

    const dim = img.getAttribute('data-image-dimensions');
    let w = 0, h = 0;
    if (dim) {
      const m = dim.match(/(\d+)\s*x\s*(\d+)/i);
      if (m) { w = +m[1]; h = +m[2]; }
    }
    if (!(w && h) && img.naturalWidth && img.naturalHeight) {
      w = img.naturalWidth; h = img.naturalHeight;
    }
    if (!(w && h)) return;

    const isLandscape = w >= h;
    slide.style.setProperty('--ap-aspect', isLandscape ? '4 / 3' : '3 / 4');
    slide.setAttribute('data-ap-aspect', isLandscape ? '4/3' : '3/4');
  }

  function enforceGaps(root) {
    const scope = root || document;
    scope.querySelectorAll('.apreps .sqs-gallery.sqs-gallery-design-grid').forEach(gallery => {
      // Container-level gaps (works when container is grid)
      const grid = gallery.querySelector('.gallery-grid');
      if (grid) {
        grid.style.setProperty('row-gap', GAP_PX + 'px', 'important');
        grid.style.setProperty('gap', GAP_PX + 'px 0', 'important');
      }
      // Vertical spacing is controlled via CSS padding-bottom on .margin-wrapper.
      // Do not set inline bottom margins here to avoid double gaps.
    });
  }

  function scan(root) {
    (root || document)
      .querySelectorAll('.sqs-gallery.sqs-gallery-design-grid img.thumb-image')
      .forEach(img => {
        if (img.complete || img.getAttribute('data-image-dimensions')) {
          classify(img);
          enforceGaps(img.closest('.sqs-gallery'));
        } else {
          img.addEventListener('load', () => { classify(img); enforceGaps(img.closest('.sqs-gallery')); }, { once:true });
          setTimeout(() => { classify(img); enforceGaps(img.closest('.sqs-gallery')); }, 600);
        }
      });
    enforceGaps(root);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => scan());
  } else {
    scan();
  }

  document.addEventListener('sqs-content-loaded', e =>
    scan(e && e.detail && e.detail.target ? e.detail.target : document)
  );

  document.addEventListener('wmTabs:afterInit', () =>
    document.dispatchEvent(new CustomEvent('sqs-content-loaded', { detail: { target: document } }))
  );
  document.addEventListener('wmTabs:afterOpenTab', () =>
    setTimeout(() =>
      document.dispatchEvent(new CustomEvent('sqs-content-loaded', { detail: { target: document } })), 100)
  );

  // MutationObserver: catch lazyload DOM swaps and re-enforce gaps
  try {
    const obs = new MutationObserver(mutations => {
      for (const m of mutations) {
        if (m.addedNodes && m.addedNodes.length) {
          m.addedNodes.forEach(node => {
            if (!(node instanceof HTMLElement)) return;
            if (node.matches && (node.matches('.sqs-gallery, .sqs-gallery *'))) {
              enforceGaps(node.closest && node.closest('.sqs-gallery'));
            }
          });
        }
      }
    });
    obs.observe(document.body, { childList: true, subtree: true });
  } catch (e) { /* no-op */ }
})();
</script>
<script>
/* GLOBAL CLEANUP (AP-REPS): remove empty blocks (gallery/code/image/spacer), collapse FE cells/sections.
   - Handles first load, AJAX nav (Squarespace 7.1 mercury:load), late plugin injections, and breakpoint resizes. */
(function () {
  const VISIBLE_SEL = [
    '.sqs-gallery-item','img','picture','video','iframe','canvas',
    '.thumb-image','.slide','.sqs-image','.sqs-video-wrapper',
    '.sqs-block-content > *' // any real child inside a Squarespace block
  ].join(',');
  const BLOCK_DENYLIST = ['block-11f3e6e7']; // known duplicate ghost block id prefix

  function isEmptyBlock(block){
    // 1) If there is any obvious visible media/content, it's not empty
    if (block.querySelector(VISIBLE_SEL)) return false;

    // 2) Check text content (strip zero-width/nbsp and whitespace)
    const c = block.querySelector('.sqs-block-content') || block;
    const text = (c.textContent || '')
      .replace(/\u200B/g,'')
      .replace(/\u00A0/g,' ')
      .trim();
    if (text.length) return false;

    // 3) If there are element children, see if any are actually visible (non-zero size)
    const els = Array.from(c.children || []);
    if (els.length){
      const anyVisible = els.some(el => {
        const cs = getComputedStyle(el);
        if (['SCRIPT','STYLE','LINK','META','NOSCRIPT'].includes(el.tagName)) return false;
        return cs.display !== 'none' && cs.visibility !== 'hidden' &&
               (el.offsetWidth > 0 || el.offsetHeight > 0);
      });
      if (anyVisible) return false;
    }

    // 4) Special case: inner gallery present but has no items (still counts as empty)
    const g = block.querySelector('.sqs-gallery-block');
    if (g && g.querySelector(VISIBLE_SEL)) return false;

    // 5) Otherwise treat block as empty
    return true;
  }

  function hide(el){
    if (!el) return;
    el.style.display = 'none';
    el.style.height = 0;
    el.style.minHeight = 0;
    el.style.padding = 0;
    el.style.margin = 0;
  }

  function clean(root = document){
    // 1) Hide empty Squarespace blocks of any type
    root.querySelectorAll('.sqs-block').forEach(block => {
      // hard snipe any known bad IDs
      const id = block.id || '';
      if (BLOCK_DENYLIST.some(p => id.startsWith(p))) {
        hide(block);
        const cell = block.closest('.fe-block');
        if (cell) {
          hide(cell);
          cell.style.setProperty('--fe-block-min-height','0px');
        }
        return; // skip to next block
      }
      if (isEmptyBlock(block)) {
        hide(block);
        const wrap = block.closest('.sqs-block-gallery, .sqs-block-image, .sqs-block-code, .sqs-block-video, .sqs-block-html') || block;
        hide(wrap);
      }
    });

    // 2) Collapse empty Fluid Engine cells (fe-block) that only contain hidden/empty blocks
    root.querySelectorAll('.fe-block').forEach(cell => {
      const blocks = cell.querySelectorAll('.sqs-block');
      const anyVisible = Array.from(blocks).some(b => {
        const cs = getComputedStyle(b);
        return cs.display !== 'none' && b.offsetHeight > 0;
      });
      if (!anyVisible) {
        hide(cell);
        cell.style.setProperty('--fe-block-min-height','0px');
      }
    });

    // 3) Collapse sections that end up with no visible content
    root.querySelectorAll('section').forEach(section => {
      const anyVisible = Array.from(section.querySelectorAll('.sqs-block, .fe-block')).some(el => {
        const cs = getComputedStyle(el);
        return cs.display !== 'none' && el.offsetHeight > 0;
      });
      if (!anyVisible) hide(section);
    });
  }

  // Run early and with delayed passes to catch lazy/plugin inserts
  const init = () => { clean(); setTimeout(clean, 200); setTimeout(clean, 800); setTimeout(clean, 2000); };
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init, { once:true }); else init();

  // Squarespace 7.1 AJAX navigation
  document.addEventListener('mercury:load', init);

  // Late injections (plugins, tabs, etc.)
  new MutationObserver(() => clean()).observe(document.body, { childList:true, subtree:true });

  // Re-check on resize (different breakpoint layouts can inject or reveal empties)
  let t; window.addEventListener('resize', () => { clearTimeout(t); t = setTimeout(clean, 150); });
})();
</script>